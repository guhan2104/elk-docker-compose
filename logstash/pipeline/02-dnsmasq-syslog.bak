#input {
#  udp {
#    port => 5141
#      type => "pihole-syslog"
#      tags => ["pihole"]
#  }
#}
#
#filter {
#
#  if "pihole" in [tags] {
#    grok {
#      patterns_dir => ["/usr/share/logstash/patterns/"]
#        match => {
#          "message" => [ 
#            # query
#              "^%{DNSMASQPREFIX} query\[%{WORD:query_type}\] %{URIHOST:record} from %{IPORHOST:requestor}", 
#            # cached
#              "^%{DNSMASQPREFIX} %{WORD:cached} %{URIHOST:query_record} is %{GREEDYDATA:query_result}",
#            # reply
#              "^%{DNSMASQPREFIX} reply %{URIHOST:record} is %{GREEDYDATA:query_result}",
#            # reply from hosts file
#              "^%{DNSMASQPREFIX} %{UNIXPATH:source_file} %{URIHOST:query_record} is %{IPORHOST:query_result}",
#            # dhcp
#              "^%{DNSMASQPREFIX} %{IPORHOST:requestor}/%{NUMBER:client_transaction_id} DHCP %{HOSTNAME:query_record} is %{IPORHOST:query_result}"
##
##
##            "%{SYSLOGBASE} %{NUMBER:server_transaction_id} %{IPORHOST:requestor}/%{NUMBER:client_transaction_id} %{WORD:query_type} %{URIHOST:record} %{GREEDYDATA}",
##"%{SYSLOGBASE} %{NUMBER:server_transaction_id} %{IPORHOST:requestor}/%{NUMBER:client_transaction_id} %{WORD:action_type} %{URIHOST:query_record} %{GREEDYDATA}",
##
##            "%{SYSLOGPRI}%{SYSLOGTIMESTAMP:date} %{SYSLOGHOST:syslog_host} %{SYSLOGPROG:process}: %{NUMBER:server_transaction_id} %{IPORHOST:requestor}/%{NUMBER:client_transaction_id} %{WORD:action_type}(reply|query[A]|query[AAAA]|cached|forwarded|%{UNIXPATH:resolved_from}),
##            
##            "^%{DNSMASQPREFIX} config %{FQDN:domain_request} is NXDOMAIN$",
### response config domain is no-DATA
##            "^%{DNSMASQPREFIX} config %{FQDN:domain_request} is NODATA-IPv[4,6]$",
### piholed
##            "^%{DNSMASQPREFIX} \/etc\/pihole\/gravity\.list %{FQDN:blocked_domain} is %{IP:pihole}$",
### piholed local
##            "^%{DNSMASQPREFIX} \/etc\/pihole\/local\.list %{FQDN:blocked_domain} is %{IP:pihole}$",
### blacklist
##            "^%{DNSMASQPREFIX} \/etc\/pihole\/black\.list %{FQDN:blocked_domain} is %{IP:pihole}$",
### regex
##            "^%{DNSMASQPREFIX} \/etc\/pihole\/regex\.list %{FQDN:blocked_domain} is %{IP:pihole}$",
### reverse response etc hosts ip to domain
##            "^%{DNSMASQPREFIX} \/etc\/hosts %{IP:ip_request} is %{FQDN:domain_response}$",
### reverse response etc hosts domain to ip
##            "^%{DNSMASQPREFIX} \/etc\/hosts %{FQDN:domain_request} is %{IP:ip_response}$",
### cached domain to ip
##            "^%{DNSMASQPREFIX} cached %{FQDN:domain_request} is %{IP:ip_response}$",
### cached ip to domain
##            "^%{DNSMASQPREFIX} cached %{IP:ip_request} is %{FQDN:domain_response}$",
### cached domain to ip cname
##            "^%{DNSMASQPREFIX} cached %{FQDN:domain_request} is \<CNAME\>$",
### cached domain is NXDOMAIN
##            "^%{DNSMASQPREFIX} cached %{FQDN:domain_request} is NXDOMAIN$",
### cached domain is no-DATA
##            "^%{DNSMASQPREFIX} cached %{FQDN:domain_request} is NODATA-IPv[4,6]$",
### domain is no-DATA
##            "^%{DNSMASQPREFIX} reply %{FQDN:domain_request} is NODATA-IPv[4,6]$",
### SRV
##            "^%{DNSMASQPREFIX} query\[%{WORD:query_type}\] %{HOSTNAMEPTR:request} from %{IP:request_from}$",
### SRV forwarded
##            "^%{DNSMASQPREFIX} forwarded %{HOSTNAMEPTR:request} to %{IP:dns_forward_to}$" ,
### SERVFAIL
##            "^%{DNSMASQPREFIX} reply error is SERVFAIL" 
#              ]
#        }
#    }
#
## to do cached and cached reverse
#
#    if [message] =~ "cached" and [message] =~ "NXDOMAIN" {
#      mutate {
#        add_tag => [ "cached NXDOMAIN" ]
#      }
#    }
#
#    else if [NODATA-IPv4] {
#      mutate {
#        add_tag => [ "NODATA" ]
#      }
#    }
#
#    else if [NODATA-IPv6] {
#      mutate {
#        add_tag => [ "NODATA" ]
#      }
#    }
#
#    else if [request_from] and [message] =~ "query" {
#      mutate {
#        add_tag => [ "request and query type" ]
#      }
#    }
#
#    else if [ip_response] and [message] =~ "reply" {
#      geoip {
#        source => "query_result"
#      }
#      mutate {
#        add_tag => [ "response domain to ip" ]
#      }
#    }
#
#    else if [message] =~ "CNAME" and [message] =~ "reply" {
#      mutate {
#        add_tag => [ "response domain to ip CNAME" ]
#      }
#    }
#
#    else if [domain_response] and [message] =~ "reply" {
#      mutate {
#        add_tag => [ "response ip to domain" ]
#      }
#      geoip {
#        source => "query_result"
#      }
#    }
#
#    else if [blocked_domain] {
#      mutate {
#        add_tag => [ "piholed" ]
#      }
#    }
#
#    else if [message] =~ "\/etc\/hosts" {
#      mutate {
#        add_tag => [ "reverse hostsfile" ]
#      }
#    }
#
#    else if [dns_forward_to] {
#      mutate {
#        add_tag => [ "dns forward" ]
#      }
#    }
#
#    else if [ip_request] and [message] =~ "cached" {
#      mutate {
#        add_tag => [ "cached ip to domain" ]
#      }
#      geoip {
#        source => "query_record"
#      }
#    }
#
#    else if [domain_request] and [message] =~ "cached" and [message] =~ "CNAME" {
#      mutate {
#        add_tag => [ "cached domain to ip cname" ]
#      }
#    }
#
#    else if [domain_request] and [message] =~ "cached" {
#      mutate {
#        add_tag => [ "cached domain to ip" ]
#      }
#      geoip {
#        source => "query_result"
#      }
#    }
#
#
#    mutate {
#      add_field => {
#        "[source_fqdn]" => "%{requestor}"
#      }
#    }
#
#    dns {
#      reverse => ["source_fqdn"]
#        action => "replace"
#        hit_cache_size => 4096
#        hit_cache_ttl => 900
#        failed_cache_size => 512
#        failed_cache_ttl => 900
#    }
#
#
#    date {
#      match => [ "date", "yyyy-MM-dd","MMM  d HH:mm:ss","MMM dd HH:mm:ss" ]
#    }
#
#  }
#}
#
#
#output {
#  stdout { codec => rubydebug }
#  elasticsearch {
#    hosts => ["elasticsearch:9200"]
#      manage_template => true
#      index => "logstash-syslog-dns-%{+YYYY.MM}"
#  }
#}
